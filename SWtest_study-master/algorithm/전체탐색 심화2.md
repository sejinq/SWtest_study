# 전체탐색 심화2

### 경찰차

각 도로에 번호가 할당되어 있음. 각 도로의 사이의 거리는 1이다(1, 1), (N, N)에 위치한 경찰차 2대가 w개의 사건이 발생한 지점에 이동한다. 1개의 사건에는 1대의 경찰차가 배치된다. 사건들을 차례로 처리하며 움직이는 최단 거리를 구하라.

N의 최대값이 1000일 때, 경찰차가 위치할 수 있는 위치는 1000X1000이지만 사건이 일어난 위치에만 존재하므로 실제 경찰차가 위치할 수 있는 가능성은 W+2이다.

solve(a, b, d) // max(a, b)번 사건까지 처리하면서 d만큼 이동한 후, 1번 경찰차는 a사건의 위치에 2번 경찰차는 b사건 위치에 있는 상태

```c++
void solve(int a, int b, int d){
  int next = (a>b? a:b)+1;
  if(next>=m+2) 	//다음 사건을 처리할 번호>=처리할 총 사건 수+2(더이상 사건이 발생하지 않았다)
  {
    if(d>ans) ans=d; //최소거리 갱신
    return;
  }
  solve(next, b, d+dis(a, next));
  solve(a, next, d+dis(b, next));
  
}
```



### 소방차

2개의 소방차의 호수의 길이를 최소로하라

가능한 모든 경우의 수 계산해 보고 최소값 찾기

f(p, k, h) // 펌프번호 p, 소방차 번호 k, 누적 호수 길이

거스름돈 문제와 유사

```c++
void g(int pt, int ft, int h){
  if(ft==f){	//펌프를 선택한 소방차의 개수가 기존의 소방차 개수가 같으면 매치가 끝났다는 뜻
    mh = min(mh, h);
    return;
  }
  for(int i=1;i<=p;i++){
    if(pv[i]==0){	//사용중이라는 거 체크 배열
      pv[i] =1;
      h+=abs(pp[i] - fp[ft+1]); //선택 누적
      g(i, ft+1, h); 
      h-=abs(pp[i] - fp[ft+1]); //백트렉킹. 선택되지 않은 누적되지 않은 상태
      pv[i]=0;
    }
  }
}
```



